БИНАРНОЕ ДЕРЕВО ПОИСКА (Binary Search Tree)

ОСНОВНЫЕ ОПЕРАЦИИ:
• insert(T element) - вставка элемента
• contains(T element) - проверка наличия
• remove(T element) - удаление элемента
• findMin() - поиск минимального элемента
• findMax() - поиск максимального элемента

РЕАЛИЗАЦИЯ:
class BinarySearchTree<T extends Comparable<T>> {
    private Node<T> root;    // корень дерева
    private int size;

    private static class Node<T> {
        T data;
        Node<T> left;
        Node<T> right;
        Node<T> parent;     // опционально
    }

СЛОЖНОСТЬ ОПЕРАЦИЙ:
┌───────────────┬───────────────┬──────────┐
│ Операция      │ Время         │ Память   │
├───────────────┼───────────────┼──────────┤
│ insert()      │ O(h)          │ O(h)     │
│ contains()    │ O(h)          │ O(h)     │
│ remove()      │ O(h)          │ O(h)     │
│ findMin()     │ O(h)          │ O(1)     │
│ findMax()     │ O(h)          │ O(1)     │
│ обход inorder │ O(n)          │ O(h)     │
└───────────────┴───────────────┴──────────┘
где h - высота дерева, n - количество узлов

СВОЙСТВА BST:
• Левый потомок < Родитель < Правый потомок
• In-order обход дает отсортированную последовательность

ТИПЫ УДАЛЕНИЯ:
1. Узел без детей - просто удаляем
2. Узел с одним ребенком - заменяем ребенком
3. Узел с двумя детьми - находим преемника (мин в правом поддереве)

ПРЕИМУЩЕСТВА:
• Автоматическая сортировка элементов
• Эффективный поиск O(log n) в сбалансированном дереве
• Динамический размер

НЕДОСТАТКИ:
• Может выродиться в связный список O(n)
• Требует балансировки для поддержания эффективности
• Сложнее реализации чем у массива/списка

БАЛАНСИРОВКА:
• AVL деревья - строгая балансировка
• Красно-черные деревья - менее строгая, но эффективная
• B-деревья - для внешней памяти

ОБЛАСТИ ПРИМЕНЕНИЯ:
• Базы данных и файловые системы
• Реализация множеств и словарей
• Сортировка больших объемов данных
• Геометрические алгоритмы